// node_modules/three-gltf-extensions/loaders/KHR_materials_variants/KHR_materials_variants.js
var ensureUniqueNames = (variantNames) => {
  const uniqueNames = [];
  const knownNames = /* @__PURE__ */ new Set();
  for (const name of variantNames) {
    let uniqueName = name;
    let suffix = 0;
    while (knownNames.has(uniqueName)) {
      uniqueName = name + "." + ++suffix;
    }
    knownNames.add(uniqueName);
    uniqueNames.push(uniqueName);
  }
  return uniqueNames;
};
var mappingsArrayToTable = (extensionDef, variantNames) => {
  const table = {};
  for (const mapping of extensionDef.mappings) {
    for (const variant of mapping.variants) {
      table[variantNames[variant]] = {
        material: null,
        gltfMaterialIndex: mapping.material
      };
    }
  }
  return table;
};
var compatibleObject = (object) => {
  return object.material !== void 0 && // easier than (!object.isMesh && !object.isLine && !object.isPoints)
  object.userData && // just in case
  object.userData.variantMaterials;
};
var traversePair = (obj1, obj2, callback) => {
  callback(obj1, obj2);
  for (let i = 0; i < obj1.children.length; i++) {
    traversePair(obj1.children[i], obj2.children[i], callback);
  }
};
var copyVariantMaterials = (dst, src) => {
  if (src.userData.variantMaterials !== void 0) {
    dst.userData.variantMaterials = Object.assign({}, src.userData.variantMaterials);
  }
  if (src.userData.originalMaterial !== void 0) {
    dst.userData.originalMaterial = src.userData.originalMaterial;
  }
};
var GLTFMaterialsVariantsExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = "KHR_materials_variants";
  }
  // Note that the following properties will be overridden even if they are pre-defined
  // - gltf.userData.variants
  // - mesh.userData.variantMaterials
  afterRoot(gltf) {
    const parser = this.parser;
    const json = parser.json;
    if (!json.extensions || !json.extensions[this.name]) {
      return null;
    }
    const extensionDef = json.extensions[this.name];
    const variantsDef = extensionDef.variants || [];
    const variants = ensureUniqueNames(variantsDef.map((v) => v.name));
    for (const scene of gltf.scenes) {
      scene.traverse((object) => {
        const association = parser.associations.get(object);
        if (!association || association.meshes === void 0 || association.primitives === void 0) {
          return;
        }
        const meshDef = json.meshes[association.meshes];
        const primitiveDef = meshDef.primitives[association.primitives];
        const extensionsDef = primitiveDef.extensions;
        if (!extensionsDef || !extensionsDef[this.name]) {
          return;
        }
        object.userData.variantMaterials = mappingsArrayToTable(extensionsDef[this.name], variants);
      });
    }
    gltf.userData.variants = variants;
    gltf.functions = gltf.functions || {};
    const switchMaterial = async (object, variantName, onUpdate) => {
      if (!object.userData.originalMaterial) {
        object.userData.originalMaterial = object.material;
      }
      const oldMaterial = object.material;
      let gltfMaterialIndex = null;
      if (variantName === null || !object.userData.variantMaterials[variantName]) {
        object.material = object.userData.originalMaterial;
        if (parser.associations.has(object.material)) {
          gltfMaterialIndex = parser.associations.get(object.material).index;
        }
      } else {
        const variantMaterialParam = object.userData.variantMaterials[variantName];
        if (variantMaterialParam.material) {
          object.material = variantMaterialParam.material;
          if (variantMaterialParam.gltfMaterialIndex !== void 0) {
            gltfMaterialIndex = variantMaterialParam.gltfMaterialIndex;
          }
        } else {
          gltfMaterialIndex = variantMaterialParam.gltfMaterialIndex;
          object.material = await parser.getDependency("material", gltfMaterialIndex);
          parser.assignFinalMaterial(object);
          variantMaterialParam.material = object.material;
        }
      }
      if (onUpdate !== null) {
        onUpdate(object, oldMaterial, gltfMaterialIndex);
      }
    };
    const ensureLoadVariants = (object) => {
      const currentMaterial = object.material;
      const variantMaterials = object.userData.variantMaterials;
      const pending = [];
      for (const variantName in variantMaterials) {
        const variantMaterial = variantMaterials[variantName];
        if (variantMaterial.material) {
          continue;
        }
        const materialIndex = variantMaterial.gltfMaterialIndex;
        pending.push(parser.getDependency("material", materialIndex).then((material) => {
          object.material = material;
          parser.assignFinalMaterial(object);
          variantMaterials[variantName].material = object.material;
        }));
      }
      return Promise.all(pending).then(() => {
        object.material = currentMaterial;
      });
    };
    gltf.functions.selectVariant = (object, variantName, doTraverse = true, onUpdate = null) => {
      const pending = [];
      if (doTraverse) {
        object.traverse((o) => compatibleObject(o) && pending.push(switchMaterial(o, variantName, onUpdate)));
      } else {
        compatibleObject(object) && pending.push(switchMaterial(object, variantName, onUpdate));
      }
      return Promise.all(pending);
    };
    gltf.functions.ensureLoadVariants = (object, doTraverse = true) => {
      const pending = [];
      if (doTraverse) {
        object.traverse((o) => compatibleObject(o) && pending.push(ensureLoadVariants(o)));
      } else {
        compatibleObject(object) && pending.push(ensureLoadVariants(object));
      }
      return Promise.all(pending);
    };
    gltf.functions.copyVariantMaterials = (dst, src, doTraverse = true) => {
      if (doTraverse) {
        traversePair(dst, src, (dst2, src2) => copyVariantMaterials(dst2, src2));
      } else {
        copyVariantMaterials(dst, src);
      }
    };
  }
};
export {
  GLTFMaterialsVariantsExtension as default
};
//# sourceMappingURL=three-gltf-extensions_loaders_KHR_materials_variants_KHR_materials_variants__js.js.map
