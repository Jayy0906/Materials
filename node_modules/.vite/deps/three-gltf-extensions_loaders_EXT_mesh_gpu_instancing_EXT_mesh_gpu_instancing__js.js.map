{
  "version": 3,
  "sources": ["../../three-gltf-extensions/loaders/EXT_mesh_gpu_instancing/EXT_mesh_gpu_instancing.js"],
  "sourcesContent": ["import {InstancedMesh, Object3D} from 'three';\r\n\r\n/**\r\n * GPU Instancing Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\r\n *\r\n */\r\nexport default class GLTFMeshGpuInstancingExtension {\r\n  constructor(parser) {\r\n    this.name = 'EXT_mesh_gpu_instancing';\r\n    this.parser = parser;\r\n  }\r\n\r\n  createNodeMesh(nodeIndex) {\r\n    const json = this.parser.json;\r\n    const nodeDef = json.nodes[nodeIndex];\r\n\r\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] ||\r\n      nodeDef.mesh === undefined) {\r\n      return null;\r\n    }\r\n\r\n    const extensionDef = nodeDef.extensions[this.name];\r\n    const attributesDef = extensionDef.attributes;\r\n\r\n    // @TODO: Should we directly create InstancedMesh, not from regular Mesh?\r\n    // @TODO: Can we support InstancedMesh + SkinnedMesh?\r\n    const pending = [];\r\n    const attributes = {};\r\n    for (const key in attributesDef) {\r\n      pending.push(this.parser.getDependency('accessor', attributesDef[key]).then(accessor => {\r\n        attributes[key] = accessor;\r\n        return attributes[key];\r\n      }));\r\n    }\r\n\r\n    if (pending.length < 1) {\r\n      return null;\r\n    }\r\n\r\n    pending.push(this.parser.createNodeMesh(nodeIndex));\r\n\r\n    return Promise.all(pending).then(results => {\r\n      const nodeObject = results.pop();\r\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];\r\n      const count = results[0].count; // All attribute counts should be same\r\n      const instancedMeshes = [];\r\n\r\n      for (const mesh of meshes) {\r\n        // Temporal variables\r\n        const m = mesh.matrix.clone();\r\n        const p = mesh.position.clone().set(0, 0, 0);\r\n        const q = mesh.quaternion.clone().set(0, 0, 0, 1);\r\n        const s = mesh.scale.clone().set(1, 1, 1);\r\n\r\n        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);\r\n        for (let i = 0; i < count; i++) {\r\n          if (attributes.TRANSLATION) {\r\n            p.fromBufferAttribute(attributes.TRANSLATION, i);\r\n          }\r\n          if (attributes.ROTATION) {\r\n            q.fromBufferAttribute(attributes.ROTATION, i);\r\n          }\r\n          if (attributes.SCALE) {\r\n            s.fromBufferAttribute(attributes.SCALE, i);\r\n          }\r\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s));\r\n        }\r\n\r\n        // We store other attributes to mesh.geometry so far.\r\n        for (const attributeName in attributes) {\r\n          if (attributeName !== 'TRANSLATION' &&\r\n            attributeName !== 'ROTATION' &&\r\n            attributeName !== 'SCALE') {\r\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);\r\n          }\r\n        }\r\n\r\n        // Just in case\r\n        Object3D.prototype.copy.call(instancedMesh, mesh);\r\n\r\n        instancedMesh.frustumCulled = false;\r\n        this.parser.assignFinalMaterial(instancedMesh);\r\n\r\n        instancedMeshes.push(instancedMesh);\r\n      }\r\n\r\n      if (nodeObject.isGroup) {\r\n        while (nodeObject.children.length > 0) {\r\n          nodeObject.remove(nodeObject.children[0]);\r\n        }\r\n\r\n        for (const instancedMesh of instancedMeshes) {\r\n          nodeObject.add(instancedMesh);\r\n        }\r\n        return nodeObject;\r\n      }\r\n\r\n      return instancedMeshes[0];\r\n    });\r\n  }\r\n}\r\n"],
  "mappings": ";;;;;;AAQA,IAAqB,iCAArB,MAAoD;AAAA,EAClD,YAAY,QAAQ;AAClB,SAAK,OAAO;AACZ,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,eAAe,WAAW;AACxB,UAAM,OAAO,KAAK,OAAO;AACzB,UAAM,UAAU,KAAK,MAAM,SAAS;AAEpC,QAAI,CAAC,QAAQ,cAAc,CAAC,QAAQ,WAAW,KAAK,IAAI,KACtD,QAAQ,SAAS,QAAW;AAC5B,aAAO;AAAA,IACT;AAEA,UAAM,eAAe,QAAQ,WAAW,KAAK,IAAI;AACjD,UAAM,gBAAgB,aAAa;AAInC,UAAM,UAAU,CAAC;AACjB,UAAM,aAAa,CAAC;AACpB,eAAW,OAAO,eAAe;AAC/B,cAAQ,KAAK,KAAK,OAAO,cAAc,YAAY,cAAc,GAAG,CAAC,EAAE,KAAK,cAAY;AACtF,mBAAW,GAAG,IAAI;AAClB,eAAO,WAAW,GAAG;AAAA,MACvB,CAAC,CAAC;AAAA,IACJ;AAEA,QAAI,QAAQ,SAAS,GAAG;AACtB,aAAO;AAAA,IACT;AAEA,YAAQ,KAAK,KAAK,OAAO,eAAe,SAAS,CAAC;AAElD,WAAO,QAAQ,IAAI,OAAO,EAAE,KAAK,aAAW;AAC1C,YAAM,aAAa,QAAQ,IAAI;AAC/B,YAAM,SAAS,WAAW,UAAU,WAAW,WAAW,CAAC,UAAU;AACrE,YAAM,QAAQ,QAAQ,CAAC,EAAE;AACzB,YAAM,kBAAkB,CAAC;AAEzB,iBAAW,QAAQ,QAAQ;AAEzB,cAAM,IAAI,KAAK,OAAO,MAAM;AAC5B,cAAM,IAAI,KAAK,SAAS,MAAM,EAAE,IAAI,GAAG,GAAG,CAAC;AAC3C,cAAM,IAAI,KAAK,WAAW,MAAM,EAAE,IAAI,GAAG,GAAG,GAAG,CAAC;AAChD,cAAM,IAAI,KAAK,MAAM,MAAM,EAAE,IAAI,GAAG,GAAG,CAAC;AAExC,cAAM,gBAAgB,IAAI,cAAc,KAAK,UAAU,KAAK,UAAU,KAAK;AAC3E,iBAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC9B,cAAI,WAAW,aAAa;AAC1B,cAAE,oBAAoB,WAAW,aAAa,CAAC;AAAA,UACjD;AACA,cAAI,WAAW,UAAU;AACvB,cAAE,oBAAoB,WAAW,UAAU,CAAC;AAAA,UAC9C;AACA,cAAI,WAAW,OAAO;AACpB,cAAE,oBAAoB,WAAW,OAAO,CAAC;AAAA,UAC3C;AACA,wBAAc,YAAY,GAAG,EAAE,QAAQ,GAAG,GAAG,CAAC,CAAC;AAAA,QACjD;AAGA,mBAAW,iBAAiB,YAAY;AACtC,cAAI,kBAAkB,iBACpB,kBAAkB,cAClB,kBAAkB,SAAS;AAC3B,iBAAK,SAAS,aAAa,eAAe,WAAW,aAAa,CAAC;AAAA,UACrE;AAAA,QACF;AAGA,iBAAS,UAAU,KAAK,KAAK,eAAe,IAAI;AAEhD,sBAAc,gBAAgB;AAC9B,aAAK,OAAO,oBAAoB,aAAa;AAE7C,wBAAgB,KAAK,aAAa;AAAA,MACpC;AAEA,UAAI,WAAW,SAAS;AACtB,eAAO,WAAW,SAAS,SAAS,GAAG;AACrC,qBAAW,OAAO,WAAW,SAAS,CAAC,CAAC;AAAA,QAC1C;AAEA,mBAAW,iBAAiB,iBAAiB;AAC3C,qBAAW,IAAI,aAAa;AAAA,QAC9B;AACA,eAAO;AAAA,MACT;AAEA,aAAO,gBAAgB,CAAC;AAAA,IAC1B,CAAC;AAAA,EACH;AACF;",
  "names": []
}
