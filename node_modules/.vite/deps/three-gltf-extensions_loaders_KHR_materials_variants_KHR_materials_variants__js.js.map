{
  "version": 3,
  "sources": ["../../three-gltf-extensions/loaders/KHR_materials_variants/KHR_materials_variants.js"],
  "sourcesContent": ["/**\r\n * Materials variants extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants\r\n */\r\n\r\n/**\r\n * KHR_materials_variants specification allows duplicated variant names\r\n * but it makes handling the extension complex.\r\n * We ensure tha names and make it easier.\r\n * If you want to export the extension with the original names\r\n * you are recommended to write GLTFExporter plugin to restore the names.\r\n *\r\n * @param variantNames {Array<string>}\r\n * @return {Array<string>}\r\n */\r\nconst ensureUniqueNames = (variantNames) => {\r\n  const uniqueNames = [];\r\n  const knownNames = new Set();\r\n\r\n  for (const name of variantNames) {\r\n    let uniqueName = name;\r\n    let suffix = 0;\r\n    // @TODO: An easy solution.\r\n    //        O(N^2) in the worst scenario where N is variantNames.length.\r\n    //        Fix me if needed.\r\n    while (knownNames.has(uniqueName)) {\r\n      uniqueName = name + '.' + (++suffix);\r\n    }\r\n    knownNames.add(uniqueName);\r\n    uniqueNames.push(uniqueName);\r\n  }\r\n\r\n  return uniqueNames;\r\n};\r\n\r\n/**\r\n * Convert mappings array to table object to make handling the extension easier.\r\n *\r\n * @param extensionDef {glTF.meshes[n].primitive.extensions.KHR_materials_variants}\r\n * @param variantNames {Array<string>} Required to be unique names\r\n * @return {Object}\r\n */\r\nconst mappingsArrayToTable = (extensionDef, variantNames) => {\r\n  const table = {};\r\n  for (const mapping of extensionDef.mappings) {\r\n    for (const variant of mapping.variants) {\r\n      table[variantNames[variant]] = {\r\n        material: null,\r\n        gltfMaterialIndex: mapping.material\r\n      };\r\n    }\r\n  }\r\n  return table;\r\n};\r\n\r\n/**\r\n * @param object {THREE.Object3D}\r\n * @return {boolean}\r\n */\r\nconst compatibleObject = object => {\r\n  return object.material !== undefined && // easier than (!object.isMesh && !object.isLine && !object.isPoints)\r\n    object.userData && // just in case\r\n    object.userData.variantMaterials;\r\n};\r\n\r\n/**\r\n * @param obj1 {THREE.Object3D}\r\n * @param obj2 {THREE.Object3D}\r\n * @param callback {function}\r\n */\r\nconst traversePair = (obj1, obj2, callback) => {\r\n  callback(obj1, obj2);\r\n  // Assume obj1 and obj2 have the same tree structure\r\n  for (let i = 0; i < obj1.children.length; i++) {\r\n    traversePair(obj1.children[i], obj2.children[i], callback);\r\n  }\r\n};\r\n\r\n// Variant materials and original material instances are stored under\r\n// object.userData.variantMaterials/originalMaterial.\r\n// Three.js Object3D.cppy/clone() doesn't copy/clone Three.js objects under\r\n// .userData so this function is a workaround.\r\n/**\r\n * @param dst {THREE.Object3D}\r\n * @param src {THREE.Object3D}\r\n * @param callback {function}\r\n */\r\nconst copyVariantMaterials = (dst, src) => {\r\n  if (src.userData.variantMaterials !== undefined) {\r\n    dst.userData.variantMaterials = Object.assign({}, src.userData.variantMaterials);\r\n  }\r\n  if (src.userData.originalMaterial !== undefined) {\r\n    dst.userData.originalMaterial = src.userData.originalMaterial;\r\n  }\r\n};\r\n\r\nexport default class GLTFMaterialsVariantsExtension {\r\n  constructor(parser) {\r\n    this.parser = parser;\r\n    this.name = 'KHR_materials_variants';\r\n  }\r\n\r\n  // Note that the following properties will be overridden even if they are pre-defined\r\n  // - gltf.userData.variants\r\n  // - mesh.userData.variantMaterials\r\n  afterRoot(gltf) {\r\n    const parser = this.parser;\r\n    const json = parser.json;\r\n\r\n    if (!json.extensions || !json.extensions[this.name]) {\r\n      return null;\r\n    }\r\n\r\n    const extensionDef = json.extensions[this.name];\r\n    const variantsDef = extensionDef.variants || [];\r\n    const variants = ensureUniqueNames(variantsDef.map(v => v.name));\r\n\r\n    for (const scene of gltf.scenes) {\r\n      // Save the variants data under associated mesh.userData\r\n      scene.traverse(object => {\r\n        const association = parser.associations.get(object);\r\n\r\n        if (!association || association.meshes === undefined || association.primitives === undefined) {\r\n          return;\r\n        }\r\n\r\n        const meshDef = json.meshes[association.meshes];\r\n        const primitiveDef = meshDef.primitives[association.primitives];\r\n        const extensionsDef = primitiveDef.extensions;\r\n\r\n        if (!extensionsDef || !extensionsDef[this.name]) {\r\n          return;\r\n        }\r\n\r\n        // object should be Mesh\r\n        object.userData.variantMaterials = mappingsArrayToTable(extensionsDef[this.name], variants);\r\n      });\r\n    }\r\n\r\n    gltf.userData.variants = variants;\r\n\r\n    // @TODO: Adding new unofficial property .functions.\r\n    //        It can be problematic especially with TypeScript?\r\n    gltf.functions = gltf.functions || {};\r\n\r\n    /**\r\n     * @param object {THREE.Mesh}\r\n     * @param variantName {string|null}\r\n     * @return {Promise}\r\n     */\r\n    const switchMaterial = async (object, variantName, onUpdate) => {\r\n      if (!object.userData.originalMaterial) {\r\n        object.userData.originalMaterial = object.material;\r\n      }\r\n\r\n      const oldMaterial = object.material;\r\n      let gltfMaterialIndex = null;\r\n\r\n      if (variantName === null || !object.userData.variantMaterials[variantName]) {\r\n        object.material = object.userData.originalMaterial;\r\n        if (parser.associations.has(object.material)) {\r\n          gltfMaterialIndex = parser.associations.get(object.material).index;\r\n        }\r\n      } else {\r\n        const variantMaterialParam = object.userData.variantMaterials[variantName];\r\n\r\n        if (variantMaterialParam.material) {\r\n          object.material = variantMaterialParam.material;\r\n          if (variantMaterialParam.gltfMaterialIndex !== undefined) {\r\n            gltfMaterialIndex = variantMaterialParam.gltfMaterialIndex;\r\n          }\r\n        } else {\r\n          // Assume the variant material is defined in glTF\r\n          gltfMaterialIndex = variantMaterialParam.gltfMaterialIndex;\r\n          object.material = await parser.getDependency('material', gltfMaterialIndex);\r\n          parser.assignFinalMaterial(object);\r\n          variantMaterialParam.material = object.material;\r\n        }\r\n      }\r\n\r\n      if (onUpdate !== null) {\r\n        onUpdate(object, oldMaterial, gltfMaterialIndex);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * @param object {THREE.Mesh}\r\n     * @return {Promise}\r\n     */\r\n    const ensureLoadVariants = object => {\r\n      const currentMaterial = object.material;\r\n      const variantMaterials = object.userData.variantMaterials;\r\n      const pending = [];\r\n      for (const variantName in variantMaterials) {\r\n        const variantMaterial = variantMaterials[variantName];\r\n        if (variantMaterial.material) {\r\n          continue;\r\n        }\r\n        const materialIndex = variantMaterial.gltfMaterialIndex;\r\n        pending.push(parser.getDependency('material', materialIndex).then(material => {\r\n          object.material = material;\r\n          parser.assignFinalMaterial(object);\r\n          variantMaterials[variantName].material = object.material;\r\n        }));\r\n      }\r\n      return Promise.all(pending).then(() => {\r\n        object.material = currentMaterial;\r\n      });\r\n    };\r\n\r\n    /**\r\n     * @param object {THREE.Object3D}\r\n     * @param variantName {string|null}\r\n     * @param doTraverse {boolean} Default is true\r\n     * @return {Promise}\r\n     */\r\n    gltf.functions.selectVariant = (object, variantName, doTraverse = true, onUpdate = null) => {\r\n      const pending = [];\r\n      if (doTraverse) {\r\n        object.traverse(o => compatibleObject(o) && pending.push(switchMaterial(o, variantName, onUpdate)));\r\n      } else {\r\n        compatibleObject(object) && pending.push(switchMaterial(object, variantName, onUpdate));\r\n      }\r\n      return Promise.all(pending);\r\n    };\r\n\r\n    /**\r\n     * @param object {THREE.Object3D}\r\n     * @param doTraverse {boolean} Default is true\r\n     * @return {Promise}\r\n     */\r\n    gltf.functions.ensureLoadVariants = (object, doTraverse = true) => {\r\n      const pending = [];\r\n      if (doTraverse) {\r\n        object.traverse(o => compatibleObject(o) && pending.push(ensureLoadVariants(o)));\r\n      } else {\r\n        compatibleObject(object) && pending.push(ensureLoadVariants(object));\r\n      }\r\n      return Promise.all(pending);\r\n    };\r\n\r\n    /**\r\n     * @param dst {THREE.Object3D}\r\n     * @param src {THREE.Object3D}\r\n     * @param doTraverse {boolean} Default is true\r\n     */\r\n    gltf.functions.copyVariantMaterials = (dst, src, doTraverse = true) => {\r\n      if (doTraverse) {\r\n        traversePair(dst, src, (dst, src) => copyVariantMaterials(dst, src));\r\n      } else {\r\n        copyVariantMaterials(dst, src);\r\n      }\r\n    };\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["dst", "src"]
}
