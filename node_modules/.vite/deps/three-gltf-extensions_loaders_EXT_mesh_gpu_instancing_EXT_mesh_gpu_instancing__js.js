import {
  InstancedMesh,
  Object3D
} from "./chunk-D5NTCM2J.js";

// node_modules/three-gltf-extensions/loaders/EXT_mesh_gpu_instancing/EXT_mesh_gpu_instancing.js
var GLTFMeshGpuInstancingExtension = class {
  constructor(parser) {
    this.name = "EXT_mesh_gpu_instancing";
    this.parser = parser;
  }
  createNodeMesh(nodeIndex) {
    const json = this.parser.json;
    const nodeDef = json.nodes[nodeIndex];
    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {
      return null;
    }
    const extensionDef = nodeDef.extensions[this.name];
    const attributesDef = extensionDef.attributes;
    const pending = [];
    const attributes = {};
    for (const key in attributesDef) {
      pending.push(this.parser.getDependency("accessor", attributesDef[key]).then((accessor) => {
        attributes[key] = accessor;
        return attributes[key];
      }));
    }
    if (pending.length < 1) {
      return null;
    }
    pending.push(this.parser.createNodeMesh(nodeIndex));
    return Promise.all(pending).then((results) => {
      const nodeObject = results.pop();
      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];
      const count = results[0].count;
      const instancedMeshes = [];
      for (const mesh of meshes) {
        const m = mesh.matrix.clone();
        const p = mesh.position.clone().set(0, 0, 0);
        const q = mesh.quaternion.clone().set(0, 0, 0, 1);
        const s = mesh.scale.clone().set(1, 1, 1);
        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);
        for (let i = 0; i < count; i++) {
          if (attributes.TRANSLATION) {
            p.fromBufferAttribute(attributes.TRANSLATION, i);
          }
          if (attributes.ROTATION) {
            q.fromBufferAttribute(attributes.ROTATION, i);
          }
          if (attributes.SCALE) {
            s.fromBufferAttribute(attributes.SCALE, i);
          }
          instancedMesh.setMatrixAt(i, m.compose(p, q, s));
        }
        for (const attributeName in attributes) {
          if (attributeName !== "TRANSLATION" && attributeName !== "ROTATION" && attributeName !== "SCALE") {
            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);
          }
        }
        Object3D.prototype.copy.call(instancedMesh, mesh);
        instancedMesh.frustumCulled = false;
        this.parser.assignFinalMaterial(instancedMesh);
        instancedMeshes.push(instancedMesh);
      }
      if (nodeObject.isGroup) {
        while (nodeObject.children.length > 0) {
          nodeObject.remove(nodeObject.children[0]);
        }
        for (const instancedMesh of instancedMeshes) {
          nodeObject.add(instancedMesh);
        }
        return nodeObject;
      }
      return instancedMeshes[0];
    });
  }
};
export {
  GLTFMeshGpuInstancingExtension as default
};
//# sourceMappingURL=three-gltf-extensions_loaders_EXT_mesh_gpu_instancing_EXT_mesh_gpu_instancing__js.js.map
